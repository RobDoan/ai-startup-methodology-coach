#!/usr/bin/env node

import fs from 'fs/promises';
import path from 'path';
import ora from 'ora';
import inquirer from 'inquirer';
import { log, colors, icons } from '../utils/colors.js';
import { gitHelpers, githubHelpers } from '../utils/git.js';

async function getAvailableServices() {
  try {
    const servicesDir = await fs.readdir('services');
    const services = [];
    
    for (const service of servicesDir) {
      const servicePath = path.join('services', service);
      const isSubmodule = await gitHelpers.isSubmodule(servicePath);
      if (isSubmodule) {
        services.push(service);
      }
    }
    
    return services;
  } catch {
    return [];
  }
}

function generatePRTitle(serviceName, featureName) {
  return `feat(${serviceName}): ${featureName}`;
}

function generatePRBody(serviceName) {
  return `## Description
Brief description of changes made to ${serviceName}.

## Changes
- [ ] Add your changes here
- [ ] Update documentation if needed
- [ ] Add tests if applicable

## Testing
- [ ] Tested locally
- [ ] All tests pass

## Checklist
- [ ] Code follows project style guidelines
- [ ] Self-review completed
- [ ] Documentation updated if needed
- [ ] No breaking changes (or documented)

## Related Issues
Closes #<issue-number> (if applicable)

---
*Auto-generated by submodule workflow script*`;
}

async function createSubmodulePR(serviceName, draft = false) {
  const servicePath = path.join('services', serviceName);
  
  log.section('Creating PR for Service Submodule');
  log.item(`Service: ${colors.info(serviceName)}`);
  
  // Validate service exists
  try {
    await fs.access(servicePath);
  } catch {
    log.error(`Service '${serviceName}' not found`);
    return false;
  }
  
  // Check if it's a git repository
  if (!(await gitHelpers.isGitRepo(servicePath))) {
    log.error(`'${serviceName}' is not a git repository`);
    return false;
  }
  
  // Check if gh CLI is installed and authenticated
  if (!(await githubHelpers.isGhInstalled())) {
    log.error('GitHub CLI (gh) is not installed');
    log.info('Please install it: https://cli.github.com/');
    log.info('Or create PR manually on GitHub');
    return false;
  }
  
  if (!(await githubHelpers.isAuthenticated())) {
    log.error('GitHub CLI is not authenticated');
    log.info('Please run: gh auth login');
    return false;
  }
  
  // Get current branch
  const currentBranch = await gitHelpers.getCurrentBranch(servicePath);
  if (!currentBranch) {
    log.error('Not on a valid branch');
    return false;
  }
  
  log.item(`Current branch: ${colors.info(currentBranch)}`);
  
  // Check if we're on a feature branch
  if (['main', 'master'].includes(currentBranch)) {
    log.error('Cannot create PR from main/master branch');
    log.info('Please create a feature branch first:');
    log.info(`  npm run new-feature ${serviceName} <feature-name>`);
    return false;
  }
  
  // Check for uncommitted changes
  const hasChanges = await gitHelpers.hasUncommittedChanges(servicePath);
  if (hasChanges) {
    log.warning('Uncommitted changes detected');
    
    try {
      const status = await gitHelpers.git.status(['--short'], { cwd: servicePath });
      console.log(status);
    } catch {
      // Ignore
    }
    
    const { commitChanges } = await inquirer.prompt([
      {
        type: 'confirm',
        name: 'commitChanges',
        message: 'Commit all changes?',
        default: false,
      },
    ]);
    
    if (commitChanges) {
      let spinner = ora('Committing changes...').start();
      try {
        await gitHelpers.add('.', servicePath);
        
        const { commitMessage } = await inquirer.prompt([
          {
            type: 'input',
            name: 'commitMessage',
            message: 'Enter commit message:',
            default: `feat: update ${serviceName} - ${new Date().toISOString().split('T')[0]}`,
          },
        ]);
        
        await gitHelpers.commit(commitMessage, servicePath);
        spinner.succeed('Changes committed');
      } catch (error) {
        spinner.fail('Failed to commit changes');
        return false;
      }
    } else {
      log.error('Please commit your changes first');
      return false;
    }
  }
  
  // Check if remote branch exists and push
  const remoteBranchExists = await gitHelpers.remoteBranchExists(currentBranch, servicePath);
  
  let spinner = ora('Pushing to remote...').start();
  try {
    if (remoteBranchExists) {
      spinner.text = 'Pushing updates to remote branch...';
      await gitHelpers.push(servicePath);
    } else {
      spinner.text = 'Pushing new branch to remote...';
      await gitHelpers.push(servicePath, true, currentBranch);
    }
    spinner.succeed('Pushed to remote');
  } catch (error) {
    spinner.fail('Failed to push to remote');
    console.error(error);
    return false;
  }
  
  // Get default branch for PR target
  const defaultBranch = await gitHelpers.getDefaultBranch(servicePath);
  
  // Extract feature name from branch (assuming feature/feature-name format)
  const featureName = currentBranch.replace('feature/', '').replace(/-/g, ' ');
  
  // Create PR title and body
  const prTitle = generatePRTitle(serviceName, featureName);
  const prBody = generatePRBody(serviceName);
  
  // Check if PR already exists
  const existingPR = await githubHelpers.getPRForBranch(currentBranch, servicePath);
  
  if (existingPR && existingPR.number) {
    log.warning(`PR already exists: #${existingPR.number}`);
    log.item(`View PR: ${colors.info(existingPR.url)}`);
    
    const { updatePR } = await inquirer.prompt([
      {
        type: 'confirm',
        name: 'updatePR',
        message: 'Update existing PR?',
        default: false,
      },
    ]);
    
    if (updatePR) {
      spinner = ora('Updating existing PR...').start();
      try {
        await githubHelpers.updatePR(existingPR.number, prTitle, prBody, servicePath);
        spinner.succeed('PR updated successfully');
      } catch (error) {
        spinner.fail('Failed to update PR');
        console.error(error);
        return false;
      }
    }
  } else {
    // Create new PR
    spinner = ora('Creating new PR...').start();
    try {
      const pr = await githubHelpers.createPR(prTitle, prBody, defaultBranch, draft, servicePath);
      
      if (draft) {
        spinner.succeed(`Draft PR created: #${pr.number}`);
      } else {
        spinner.succeed(`PR created: #${pr.number}`);
      }
      
      log.item(`PR URL: ${colors.info(pr.url)}`);
    } catch (error) {
      spinner.fail('Failed to create PR');
      console.error(error);
      return false;
    }
  }
  
  // Success and next steps
  log.success('ðŸŽ‰ Submodule PR workflow complete!');
  
  log.section('Next Steps:');
  log.item('Review and merge the submodule PR');
  log.item(`Update parent repo: ${colors.info('npm run sync')}`);
  log.item(`Create parent PR: ${colors.info('npm run parent-pr')}`);
  
  log.section('Useful commands:');
  log.item(`View PR: ${colors.dim(`cd ${servicePath} && gh pr view`)}`);
  log.item(`Check PR status: ${colors.dim(`cd ${servicePath} && gh pr status`)}`);
  log.item(`Merge PR: ${colors.dim(`cd ${servicePath} && gh pr merge`)}`);
  
  return true;
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  const args = process.argv.slice(2);
  const serviceName = args.find(arg => !arg.startsWith('--'));
  const draft = args.includes('--draft');
  
  if (!serviceName) {
    log.error('Service name required');
    console.log('Usage: npm run create-pr <service-name> [--draft]');
    console.log('');
    
    getAvailableServices().then(services => {
      if (services.length > 0) {
        log.info('Available services:');
        for (const service of services) {
          log.item(service);
        }
      }
    });
    process.exit(1);
  }
  
  createSubmodulePR(serviceName, draft).catch(error => {
    log.error(`Unexpected error: ${error.message}`);
    process.exit(1);
  });
}

export default createSubmodulePR;