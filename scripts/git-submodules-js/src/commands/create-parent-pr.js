#!/usr/bin/env node

import fs from 'fs/promises';
import ora from 'ora';
import inquirer from 'inquirer';
import { log, colors, icons } from '../utils/colors.js';
import { gitHelpers, githubHelpers } from '../utils/git.js';

function generateBranchName(featureName) {
  if (featureName) {
    return `feature/submodule-${featureName}`;
  }
  return `feature/submodule-update-${new Date().toISOString().split('T')[0]}-${Date.now().toString().slice(-4)}`;
}

function generatePRTitle(featureName) {
  if (featureName) {
    return `feat: ${featureName} - submodule updates`;
  }
  return 'chore: update submodule references';
}

function generatePRBody(submoduleUpdates) {
  return `## Summary
This PR updates submodule references to include the latest changes.

## Submodules Updated
${submoduleUpdates.map(update => `- ${update}`).join('\n')}

## Submodule Status
\`\`\`
${submoduleUpdates.join('\n')}
\`\`\`

## Changes Included
<!-- Describe what changes are included in the submodule updates -->
- Update to latest submodule commits
- Include recent feature developments

## Testing
- [ ] All submodules are properly synchronized
- [ ] Application builds and runs correctly
- [ ] All tests pass

## Deployment Notes
After merging this PR, the deployment will include updates from:
${submoduleUpdates.map(update => `- ${update}`).join('\n')}

---
*Auto-generated by parent repository workflow script*`;
}

function generateCommitMessage(featureName, submoduleStatus) {
  let message = 'chore: update submodule references';
  
  if (featureName) {
    message = `feat: ${featureName} - update submodules`;
  }
  
  message += `\n\nUpdated submodules:\n${submoduleStatus.map(line => `- ${line}`).join('\n')}`;
  
  return message;
}

async function createParentPR(featureName = null, draft = false) {
  log.section('Creating PR for Parent Repository');
  
  // Check if we're in the root directory
  try {
    await fs.access('.gitmodules');
  } catch {
    log.error('Not in parent repository root');
    return false;
  }
  
  // Check if gh CLI is installed and authenticated
  if (!(await githubHelpers.isGhInstalled())) {
    log.error('GitHub CLI (gh) is not installed');
    log.info('Please install it: https://cli.github.com/');
    return false;
  }
  
  if (!(await githubHelpers.isAuthenticated())) {
    log.error('GitHub CLI is not authenticated');
    log.info('Please run: gh auth login');
    return false;
  }
  
  // Get current and default branches
  const currentBranch = await gitHelpers.getCurrentBranch();
  const defaultBranch = await gitHelpers.getDefaultBranch();
  
  log.item(`Current branch: ${colors.info(currentBranch)}`);
  log.item(`Default branch: ${colors.info(defaultBranch)}`);
  
  // Check if there are submodule changes
  log.section('Checking for submodule changes');
  
  let spinner = ora('Checking submodule status...').start();
  
  try {
    const status = await gitHelpers.git.status(['--porcelain']);
    const hasSubmoduleChanges = status.split('\n').some(line => line.startsWith('M '));
    
    if (!hasSubmoduleChanges) {
      spinner.warn('No submodule changes detected');
      log.warning('Make sure you\'ve updated submodules first:');
      log.info('  npm run sync');
      
      const { continueAnyway } = await inquirer.prompt([
        {
          type: 'confirm',
          name: 'continueAnyway',
          message: 'Continue anyway?',
          default: false,
        },
      ]);
      
      if (!continueAnyway) {
        return false;
      }
    } else {
      spinner.succeed('Submodule changes detected');
    }
  } catch (error) {
    spinner.fail('Failed to check status');
    console.error(error);
    return false;
  }
  
  // Show current submodule status
  try {
    const submoduleStatus = await gitHelpers.getSubmoduleStatus();
    log.section('Current submodule status:');
    for (const line of submoduleStatus) {
      log.item(line);
    }
  } catch (error) {
    log.warning('Could not get submodule status');
  }
  
  // Handle branch creation/switching
  let targetBranch = currentBranch;
  
  if (currentBranch === defaultBranch) {
    const featureBranch = generateBranchName(featureName);
    log.section(`Creating feature branch: ${featureBranch}`);
    
    spinner = ora('Creating feature branch...').start();
    try {
      await gitHelpers.createBranch(featureBranch);
      targetBranch = featureBranch;
      spinner.succeed(`Created and switched to: ${featureBranch}`);
    } catch (error) {
      spinner.fail('Failed to create feature branch');
      console.error(error);
      return false;
    }
  } else if (currentBranch?.startsWith('feature/')) {
    log.success(`Already on feature branch: ${currentBranch}`);
  } else {
    log.warning(`On branch: ${currentBranch}`);
    
    const { continueWithBranch } = await inquirer.prompt([
      {
        type: 'confirm',
        name: 'continueWithBranch',
        message: 'Continue with current branch?',
        default: false,
      },
    ]);
    
    if (!continueWithBranch) {
      const featureBranch = generateBranchName(featureName);
      spinner = ora('Creating feature branch...').start();
      try {
        await gitHelpers.createBranch(featureBranch);
        targetBranch = featureBranch;
        spinner.succeed(`Created and switched to: ${featureBranch}`);
      } catch (error) {
        spinner.fail('Failed to create feature branch');
        console.error(error);
        return false;
      }
    }
  }
  
  // Stage submodule changes
  spinner = ora('Staging submodule changes...').start();
  try {
    await gitHelpers.add('.');
    
    // Check what's staged
    const stagedChanges = await gitHelpers.git.diff(['--staged', '--name-only']);
    if (!stagedChanges.trim()) {
      spinner.warn('No changes to commit');
      return false;
    }
    
    spinner.succeed('Staged submodule changes');
    
    log.section('Staged changes:');
    for (const file of stagedChanges.split('\n').filter(f => f.trim())) {
      log.item(file);
    }
  } catch (error) {
    spinner.fail('Failed to stage changes');
    console.error(error);
    return false;
  }
  
  // Commit changes
  spinner = ora('Committing changes...').start();
  try {
    const submoduleStatus = await gitHelpers.getSubmoduleStatus();
    const commitMessage = generateCommitMessage(featureName, submoduleStatus);
    
    await gitHelpers.commit(commitMessage);
    spinner.succeed('Committed changes');
  } catch (error) {
    spinner.fail('Failed to commit changes');
    console.error(error);
    return false;
  }
  
  // Push branch
  spinner = ora('Pushing branch to remote...').start();
  try {
    const remoteBranchExists = await gitHelpers.remoteBranchExists(targetBranch);
    
    if (remoteBranchExists) {
      await gitHelpers.push();
    } else {
      await gitHelpers.push('.', true, targetBranch);
    }
    
    spinner.succeed('Pushed to remote');
  } catch (error) {
    spinner.fail('Failed to push to remote');
    console.error(error);
    return false;
  }
  
  // Generate PR details
  const prTitle = generatePRTitle(featureName);
  const submoduleUpdates = await gitHelpers.git.diff(['HEAD~1', '--name-only']).then(diff => 
    diff.split('\n').filter(f => f.startsWith('services/') && f.trim())
  );
  const prBody = generatePRBody(submoduleUpdates);
  
  // Check if PR already exists
  const existingPR = await githubHelpers.getPRForBranch(targetBranch);
  
  if (existingPR && existingPR.number) {
    log.warning(`PR already exists: #${existingPR.number}`);
    log.item(`View PR: ${colors.info(existingPR.url)}`);
    
    const { updatePR } = await inquirer.prompt([
      {
        type: 'confirm',
        name: 'updatePR',
        message: 'Update existing PR?',
        default: false,
      },
    ]);
    
    if (updatePR) {
      spinner = ora('Updating existing PR...').start();
      try {
        await githubHelpers.updatePR(existingPR.number, prTitle, prBody);
        spinner.succeed('PR updated successfully');
      } catch (error) {
        spinner.fail('Failed to update PR');
        console.error(error);
        return false;
      }
    }
  } else {
    // Create new PR
    spinner = ora('Creating new PR...').start();
    try {
      const pr = await githubHelpers.createPR(prTitle, prBody, defaultBranch, draft);
      
      if (draft) {
        spinner.succeed(`Draft PR created: #${pr.number}`);
      } else {
        spinner.succeed(`PR created: #${pr.number}`);
      }
      
      log.item(`PR URL: ${colors.info(pr.url)}`);
    } catch (error) {
      spinner.fail('Failed to create PR');
      console.error(error);
      return false;
    }
  }
  
  // Success and next steps
  log.success('ðŸŽ‰ Parent repository PR workflow complete!');
  
  log.section('Next Steps:');
  log.item('Review the PR and ensure all submodule updates are correct');
  log.item('Run any necessary integration tests');
  log.item('Merge the PR when ready');
  log.item('Deploy the updated application');
  
  log.section('Useful commands:');
  log.item(`View PR: ${colors.dim('gh pr view')}`);
  log.item(`Check PR status: ${colors.dim('gh pr status')}`);
  log.item(`Merge PR: ${colors.dim('gh pr merge')}`);
  log.item(`Check submodule status: ${colors.dim('git submodule status')}`);
  
  return true;
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  const args = process.argv.slice(2);
  const featureName = args.find(arg => !arg.startsWith('--'));
  const draft = args.includes('--draft');
  
  createParentPR(featureName, draft).catch(error => {
    log.error(`Unexpected error: ${error.message}`);
    process.exit(1);
  });
}

export default createParentPR;